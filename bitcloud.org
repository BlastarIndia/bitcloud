#+SEQ_TODO: TO-THINK EARLY-DRAFT LATE-DRAFT TO-IMPROVE TO-VOTE FINISHED
#+TITLE: Bitcloud: A Peer to Peer System for Sharing Bandwidth
#+LANGUAGE: en
#+STARTUP: align fold hidestars
#+OPTIONS: H:7 num:nil toc:nil \n:nil stat:nil timestamp:nil html-postamble:nil inline-images:t

* TO-IMPROVE Introduction

  Bitcloud is a new protocol proposal based on some of the ideas of
  BitTorrent and Bitcoin related technologies such as Mastercoin and
  Datacoin, and it is meant to change the way of exchanging digital
  information as opposed by the current centralized trends.

  Users adhering to this protocol will be able to:

  - Upload any file to the Bitcloud net and make it available to anyone.
  - Download and stream the content to anyone.
  - Select which moderator you want to use, from anyone.
  - Earn money from advertising or disable advertising completely.

  Nodes adhering to this protocol will be able to:

  - Generate and earn profitable income in relation to the bandwidth
    they share.
  - Select what content they cache and serve by selecting moderators.

  Moderators adhering to this protocol will be able to:

  - Approve and categorize user content.
  - Approve or ban nodes.
  - Earn profitable income throughout advertising.

  Any person can become a *user*, a *node* and/or a *moderator* at any
  time. In addition to this, there will be client applications which
  serve as an interface to the general protocol named Bitcloud. We are
  presenting Wetube as the primary interface for our first version,
  but programmers can make any kind of interface, providing that they
  follow the rules described in this protocol.

  The Bitcloud blockchain can be independently accessed for money
  transactions, so external wallets without using the main interface
  are perfectly feasible.

  Bitcloud works by following a special set of premises refered as
  /laws/. The laws in the software ensure that the system is running
  smooth without spammers and selfish serving, so everybody can trust
  the system. These laws are initially imposed by the programmers and
  can dynamically change over versions.

  The entire system can be fully scriptable in real time using simple to use
  and parse lambda expressions, so advanced users and programmers can tweak
  and modify the way in which they are connected to the Bicloud net, embed
  actions into web pages, use in their internal programs (in any language),
  etc. Nodes can be accessed in real time by their owners with full control to
  the entire running system. We are looking forward an incredible level of
  flexibility in where all users can review and enhance the living (running)
  network.

* EARLY-DRAFT Workers
** TO-IMPROVE General

A worker is basically any entity that is a *user*, a *moderator* or a
*node*. We encapsulate this into a general class because all workers
have some variables in common, like the alias or the
public-key. Then we derive the specifics workers from this class.

#+BEGIN_SRC plantuml :file "img/worker-class.png"
User:
class Worker {
 alias
 private-key
 public-key
 banned?
 banned-time
 protected?
 IP
}
Worker --|>  Node
Worker --|> Moderator
Worker --|> User
#+END_SRC

#+RESULTS:
[[file:img/worker-class.png]]

**** TO-THINK alias

Is usually the name or nick chosen by the worker. _TODO We have
to think if we want to implement our own ID system or use an
existing one like Keyhotee or Namecoin_.

**** private-key

The private key of the worker used to sign actions. Normally this
variable is only available in the computer of the worker and
nowhere else.

**** public-key

Is generated from the private key and is used for all wallet
operations plus to verify signatures in the judges and
enforcement (see below).

**** banned?

Is *t* when the enforcement rutine determines so. A banned worker
cannot use the Bitcloud for a specific period of time defined in
*banned-time*.

**** protected?

Is *t* if the worker enters into a special mode in which all the
content it uploads, moderates or stores is encrypted and enrouted
protected (the IP cannot be determined). More below.

**** IP

The actual IP of the node. NULL if protected.

** EARLY-DRAFT Nodes

Nodes are the primordial base for the Bitcloud network and most of the work
is done there.

Nodes run the program *bitcloud*. This program maintains a cache of
files served and provides the necessary bandwidth for the *Client
Applications* to work.

Nodes also do the important work of providing [[https://github.com/wetube/bitcloud/wiki/Proof-of-Bandwidth][Proof of Bandwidth]] so
the cloud runs consistently and everyone generates the money they
only deserve.

Like it happens with Bitcoin, a block reflecting all the
transactions are generated once every 10 minutes. This block
represents the consensus of the Bitcloud net about the operations
made in itself since the last block. It contains all the money
transactions made, including the ones generated by the nodes by
bandwidth sharing. In order to preserve space, it does not contain
all the details of the nodes states nor any content at all.

The blockchain is the chained collection of all blocks generated
since the born of Bitcloud. It's contents are perpetual and
immutable.

In addition, there will be a *Node Pool*. This pool is regenerated
every 10 minutes after a new block is generated and contains the
state of all nodes. When regenerated, all nodes apply the rules
under the section *Proof of Stake* to it, to ensure that every
node meets the rules and no one tries to take advantages over the
rest.

#+BEGIN_SRC plantuml :file "img/node-class.png"
class Node {
 dns-name    
 max-download-speed
 max-upload-speed
 max-space
 signature
 accepted-coins
 moderators
 preferential-moderators
 cloud-moderators
 content-waiting-for-approval
 protected?
 shutdown-date
}
Worker -right-|> Node
#+END_SRC

#+RESULTS:
[[file:img/node-class.png]]

**** max-download-speed and **max-upload-speed**

Are the variables that define how much the owner of the node
wants to share, expressed in Mb/s.

**** max-space

Is in Mb and it is the maximum size to allocate for the files
cache. When the space occupied by the cache pass this variable,
the least requested files are deleted.

**** signature

Refers to the public key of the node, used to sign transactions
in the *Proof of Stake (POS)* routines.

**** accepted-coins

Is a list of accepted coins for exchange. For example `'(BTC
LTC)`. If a node accept BTC, it must run the *bitcoind* daemon.

**** moderators

Is a list of normal moderators for which the content is accepted
to be cached. The content cached can vary, so a node can
automatically select the content to be cached in function of the
number of requests. If this variable is NIL, the node becomes
unmoderated and caches everything that goes through.

**** preferential-moderators

Is a list of moderators whose content is always going to be
cached entirely. This is useful for moderators that also own
nodes.

**** cloud-moderators

A list of moderators for cloud personal storage. These moderators
put a price for content storage. This content is guaranteed to be
stored until 1 year has passed since the user paid, or until the
user deletes it or the moderator stops supporting the user.

*Note*: the sum of the space required by the moderators in
**cloud-moderators** and **preferential-moderators** should be
less than **max-space**. *bitcloud* daemon should log a warning if
that happens, and POS policies could ban the node.

**** content-waiting-for-approval

A list of contents uploaded from the users that are waiting for
the approval of the moderators adhered to this node.

**** approval-timeout

How much time this node is going to wait for the approval on any
moderator adhered to this node. Passed that time the awaiting
content is deleted from the cache. Minimum time allowed is 12
hours. Defaults to 48.

**** protected?

Whether the node IP is protected and the content in the local
cache is encrypted with the private key of the node. But this has
some downsides, the most important is that data is routed
throughout many nodes, adding costs in bandwidth and latency.

**** shutdown-date

When is the node going to be shut down automatically. Useful for protected
nodes that serve delicate content.

** TO-THINK Moderators

Moderators are crucial to the well-working of the Bitcloud. Their
main tasks are:

+ Approve user content. The user select a list of moderators to which s/he
  wants to adhere, the moderator receives the request and decides if the
  user meets his/her requirements.
+ Categorize. A moderator properly corrects tagging of the content
  s/he receives from the user.
+ Advertising. Advertisers select which moderators they want to
  adhere, and ads are only shown in the content approved by that
  moderator. Moderators are paid for this, and they put the
  price. A part of this price goes to the publisher.

#+BEGIN_SRC plantuml :file "img/moderator-class.png"
class Moderator {
     contents
     trusted-users
     supermoderators
     advertisers
     ads-price
     ads-share-to-users
     tags
}
Worker -right-|> Moderator
#+END_SRC

#+RESULTS:
[[file:img/moderator-class.png]]

*** contents

This is a list of contents that the moderator has been approved. Nodes who have
selected this moderator have the obligation to maintain a cache with the files
this moderator approves.

*** trusted-users

** TO-THINK Users

Users are the ones that obtain the benefits from the services of nodes and
moderators, because they are who send and receive the content.

The use of the system must be transparent to the user. S/he should be able to
connect using his/her client or browser without having to do anything special
and without requiring any technological expertise.

#+BEGIN_SRC plantuml :file "img/user-class.png"
class User {
     votes
      wallet
      favorites
      moderators
      history
      updloads
}
Worker -right-|> User
#+END_SRC

#+RESULTS:
[[file:img/user-class.png]]

* EARLY-DRAFT The Bitcloud Cryptography Law (BCL)


  The Cryptography Law, also called *Proof of Stake* in more simple
  projects, is the law of Bitcloud - what governs it - providing the
  rules in the form of algorithms executed by the nodes and clients in
  real time.

  Each rule must be applied for every node or client in the
  net. Appliance to every rule is rewarded in the way described in the
  rule. Non-compliance results in penalization.

  This fine equilibrium ensures that every node does the work
  correctly and there are no abuses.

  Like in the real world, here there are laws, judges and rule
  enforcers. The main difference is that here all nodes and clients
  are the judges and the rule enforcers, so the law coming in the form
  of computer algorithms is applied by the consensus of the entire
  Bitcloud net.

  We have named every rule with an easy to remember name, so workers
  of the system can refer to them when talking to other workers and
  non technical people.

** TO-IMPROVE Law appliance

Basically, the law is applied by judging (checking) that every node
and client is doing the work as it should, so, when asked, it
should answer with the truth of what is asked. If it is found that
the node or client is lying, it is penalized or banned, and its
transactions rejected are not included in the blockchain.

Laws are written in the source code in the form of *generics* and the
corresponding *methods*. A *method* is a specific application of a
*generic*. For example, for the *generic* of the Law of Bandwidth there
are going to be several *methods* for judging nodes, users and
moderators.

This is a subprocess of the general *sync* process, as described in the
Nodepool section.

#+BEGIN_SRC plantuml :file "img/appliance1.png"
(*) -right-> [sync process] select workers to judge
-right-> judge workers
-right-> enforce verdicts
-right-> [freeze pool process] (*)
#+END_SRC

#+RESULTS:
[[file:img/appliance1.png]]


The return of those functions is always a verdict, in the form of
lambda expression, so it is easy to parse from scripts[fn:1]:

#+BEGIN_SRC lisp
   (verdict t :reward 0.2345)
   (verdict nil :penalization 1.3 :ban 6)
#+END_SRC

The first var is *t* or *nil* indicating if the verdict is favorable or
not. The rest indicates the properties of the verdict, to be
applied by the *enforce* *generic*.

The purpose of it is to certificate (sign) the verdict and write it in the
Node Pool State when appropriate. When there is general consensus (for
example, 80% or more of the workers agree with the verdict), the current Block
is frozen and added to the Blockchain, and the Node Pool State is regenerated
using relevant parts of the old data for the new start.

** EARLY-DRAFT The laws
*** Time Law
**** TO-IMPROVE GMT sync Law

     - All nodes must be in sync of time with the official world time
       at GMT with a maximum variation of 10 seconds. Clients are not
       forced.

       : (defgeneric judge-time (worker))

     - Check is made sending a request to the other node and comparing
       to the actual date in the moment of sending the request.

       : (defun request-time (node))

       Function returns `(get-universal-time)` of the other node.

     - No reward for appliance.

       : (verdict t)

     - Penalization of 1 MAC (X) for every 10 seconds out of sync on
       each block generation. Ban for Y periods if it is 30s or more
       or the node hasn't got enough money to pay penalization. All
       operations of the node for the current block are rejected (Z)
       only if time variation is bigger than 30s.

       : (verdict nil :penalization X :ban Y :reject Z)

       Y is 1 for one time ban. Y is 6 if the node persists. Y is 144
       if it persists even more. Y (1,6,144)

**** TO-IMPROVE Timestamps Law

     - All nodes must write the correct dates in all connections and
       associated transactions.

       : (defgeneric judge-timestamps (node connection))

     - Check is made looking at the states written by the node in the
       pool. All dates must be correctly dated within the period of
       the block being analyzed.

     - No rewards for appliance.

       : (verdict t)

     - Immediate penalization of 1 MAC and ban for Y (6, 144,
       288). Reject all transactions.

       : (verdict nil :penalization 1 :ban Y :reject 'all)

*** EARLY-DRAFT Lag Law

    - All workers must answer in less than X seconds to any query or
      **sync** function.

    - No rewards for appliance.

      : (verdict t)

    - Ban X(1,2,6,144) if slow or saturated connections.

      : (verdict nil :ban X)

*** TO-THINK Bandwidth Law

 : (defgeneric judge-bandwidth (worker))

**** TO-THINK Bandwidth check
**** TO-THINK Abuse Bandwidth check
*** TO-THINK Service Law
Workers must answer to queries.
**** DNS check
**** Query answer check
**** Availability check
*** TO-THINK Dispersion Law
Ensure randomness when selecting nodes.
**** Random connection check
**** Short Circuit check

*** TO-THINK Storage Law
*** TO-THINK Advertising Law
*** TO-THINK Enforcement Law
*** TO-THINK Money Law
* TO-THINK Storage and language format
** Format
*** Lambda expressions

Libraries for many languages (for example PHP, Ruby, Python and Javascript)
should be trivial to implement. Conversion to json objects should be easy and
fast.

*** Compression

Compression is very easy to implement for lambda expressions and happens in
real time when storing the blockchain in a file. We just need to assign a
constant binary number for every tag and store that number instead of full
names. Numbers can be stored in a fixed size 64 bit floating point format.

In addition, there should be a second compression pass using the standard LZO
libraries, available for all the languages.

* TO-THINK Query language
** Format
** Search engine
* TO-THINK Blockchain
** The cycle
** Simplification

In order to avoid some scalability issues, there is a process of
simplification that happens for data stored in the blockchain from certain
time backwards. This process removes all transaction data except the amount
of money owned by every account when due-date arrives.

* TO-THINK Routing
** HTTP as a base

Most communications are done using the well understood and easy to use HTTP
network protocol as a base. We choose to use HTTP because it is enough for our
requirements and because it is widely available.

We choose the default 80 port for all communications, with the option for
nodes to select any other alternatives. The reason to use this port is that
people behind a firewall can still access the complete net without the typical
restrictions. Most ISPs prioritize this port over the rest, making it the fastest
and more reliable port. Also, censorship becomes much more difficult.

Nodes wanting to use the 80 port for other purposes (like for example a
classical web server) can use any of the Unix tools available to route
domains, like for example /nginx/.

We don't use any p2p low level protocol like Bittorrent because we need very
fast access with the less possible lag. It also happens that many ISP actually
censor Bittorrent protocol. In addition, using simple HTTP will simplify the
protocol very much.

** GET/POST format

** LATE-DRAFT Serving static pages (Entry points)

We are also supporting the serving of static web pages stored in the nodes
outside of the Bitcloud, in the official Bitcloud server program. These pages
are considered a wrapper for Bitcloud. The purpose of this is to allow nodes
to become entry points for users:

- To allow the users to download a full featured client.
- To allow the users to connect "hot" using a JavaScript client.
- To allow nodes to provide informational static content only relevant to that
  node. For example, a TV channel, a book editor, a corporate web. They can
  embed content from Bitcloud in those static pages.
- To publish the statistics of the node in real time to the WWW.

*NOTE*: those static pages are considered to be out of the Bitcloud, except
if the content is embed (and only for the content), so they don't apply to the
law of Bitcloud, nor to its benefits.

In addiction to this, nodes can install their own HTTP server (like Apache)
and serve dynamic pages using local routing facilities like /nginx/.

** LATE-DRAFT Nodes are designed to run on full-featured servers

The reason for this is that Bitcloud must provide fast access and high
bandwidth availability to the users. For example, streaming a single HD video
requires an upload capacity of 1Mb/s or more, which means that some home
connections would not be able to serve even a single video, not to speak to
serve several files at a time. Also, home connections are unreliable and
change IP too often, in comparison to good properly located servers[fn:2].

We also intentionally forbid nodes without a proper DNS pointing to them, so
we enforce more reliability  when connecting to nodes.

** TO-THINK Registering a new node and connecting to the network

Every new node must register into the network and provide the necessary
details specified in the /Node class/.

** TO-THINK Dynamically find routes

Every user is connected to a randomly selected collection of 4 nodes. It must
be really random

** EARLY-DRAFT Protected nodes

When a content is marked as *protected*, the Bitcloud net protects both the IP
and domain name of the node serving the content. The user requesting the
connection is also protected. There is still a way for auditors to know that a
certain computer is acting as a node, but will not be able to know what is the
protected content that is serving. Even more, external auditors cannot
distinguish between protected and unprotected routing while analyzing the
traffic to an specific node.

We use a routing process similar to Tor Onion hidden services, optimized to
our purposes.

#+BEGIN_SRC plantuml :file "img/protected-route.png"
cloud "Middle Nodes" as MN {
}

node "Protected Node" as pnode
node Node1 {
(Node Router) as RF1
}
node Node2 {
(Route Finder) as RF2
}
node Node3 {
(Route Finder) as RF3
}
node Node4 {
(Route Finder) as RF4
}
RF1 <.down.> MN
RF2 <.down.> MN
RF3 <.down.> MN
RF4 <.down.> MN  : "<b>protected routes</b>"
(User Router) as RS
RS     <-down-> RF1
RS     <-down-> RF2
RS     <-down-> RF3
RS     <-down-> RF4
:User:     <-down-> RS : Request protected content
MN <.down.> pnode
#+END_SRC

#+RESULTS:
[[file:img/protected-route.png]]

1. The user chooses a collection of 4 random nodes. /Dispersion Law/.
2. Using the User Router (coded in the interface), the User ask all the nodes to find a
   route to the Protected Node. /Service Law/
3. Each node tries to find a competitive route to the Protected Node and answer
   fast to the User. /Service Law/
4. The Route Selector chooses the fastest one.
5. The User download/stream/upload the content throughout the fastest
   rute. /Bandwidth Law/
6. Meanwhile, the User informs the rest of the nodes about the quality of the
   conexion. /Bandwidth Law/.
7. If the quality is low, the Route Selector tries to change to other route
   Node while informing the issue. /Bandwidth Law/
8. The selected node also enforces the Bandwidth Law for the Middle Node it is
   connected to.
9. Each Middle Node also enforces the Bandwidth Law for their connections. 

** EARLY-DRAFT The User Router

The mission of the User Router is to find the fastest route to a solicited
content, whether it is protected or not.

It must be coded in the user interface and must respect the BCL in order for
the user to not be banned.

Its principles are simple, and should be easy to code in any language, even
JavaScript for the browser.

#+BEGIN_SRC plantuml :file "img/protected-route-selector.png"
(*) -down-> "Ask Entry Point for random nodes"
--> ===AN===
-down-> "Ask Node1"
-down-> ===Sync===
===AN=== --> "Ask Node2"
-down-> ===Sync===
===AN=== --> "Ask Node3"
-down-> ===Sync===
===AN=== --> "Ask Node4"
-down-> ===Sync===
-down-> "Select Fastest"
-down-> "Download/Upload/Stream"
if "is quality ok?" then
 --> [low quality] "Inform low quality to other nodes"
else
 ----> [high quality] "Inform high quality to other nodes"
 -down-> (*)
endif
"Inform low quality to other nodes" --> "ask to the next fastest"
 -> "Download/Upload/Stream"
"Inform low quality to other nodes" ..> [no more nodes] "<color:red>ERROR</color>"
#+END_SRC

#+RESULTS:
[[file:img/protected-route-selector.png]]

*** The Route Finder

#+BEGIN_SRC plantuml :file "img/protected-route-finder.png"

#+END_SRC

* TO-THINK Nodepool

The *Nodepool* contains all the information relevant to the nodes, and it is
constantly calculated in real time.

** Regeneration

* TO-THINK Sync process
* TO-THINK Node Interface

  This is the interface for the node (not the users) so the
  administrator can see and tweak values in real time.

* COMMENT TO-IMPROVE Why Lisp

  Bitcloud is much more dynamic than Bitcoin, we need dynamic
  constructs and easy adaptation to the real time requirements.

  - The REPL if very powerful and really useful, allowing to program
    and tweak the nodes in real time. Advanced users will love this.
  - Saving the blockchain in text format, and the language of queries
    in simple lambda expressions would allow many scripting languages
    to parse the blockchain and node pool states easily.
  - SBCL implementation is really fast, much faster than Python, Ruby
    or any other dynamic language. Almost as fast as C for most cases.
  - Easy to design and integrate the query language into the program,
    in contrast to what would happen in C++ having to integrate an
    alien language.
  - Bitcloud will be scriptable in the same language that has been
    made.
  - Powerful language constructors like macros and CLOS which will
    reduce programming costs.
  - Lets do the things right for once! We have the opportunity to
    avoid using a crappy language like C++ before it is too late. :)

* TO-THINK LOG examples

- This moderator offer you X mediacoins by inserting an ad into your
  content.

- You have been accused of denying storage for the moderator X. Verdict is:
  banned for 1 period and penalized with 1 MAC.

* TO-THINK Future as a Social Distributed application

  With not so much modifications, this DA could also provide social content
  with characteristics competing to those of centralized private sites like
  Facebook and Twitter.

* Footnotes

[fn:1] In order to make things easy for system administrators and programmers,
we are using lambda expressions. These are simple expressions enclosed into
parenthesis with the action in the first position. It is actually very easy to
translate from jason-format to lambda expressions. We choose lambda
expressions because they need less space and are faster to parse and write.

[fn:2] Renting a server or VPS is very cheap today.

